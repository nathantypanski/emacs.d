* Explanation
  This is my emacs init file. It's written in org-mode, because what better way
  to learn emacslisp and org-mode than to combine them both at once?

  The core of this file is [[https://gitorious.org/evil/pages/Home][Evil]], an extensible vi layer for emacs.
  It allows someone like me (multi-year vim user with a heavily tweaked
  =~/.vimrc=) to dive into Emacs with an open mind.

  While at first the journey was painful, I have undertaken the long journey
  toward Enlightenment. There shall be no Escape-Meta-Alt-Control-Shift in my
  text editing; only clearly defined motions, preferring single keypresses to
  multi-key combinations with modifiers.

  ... That's the idea, at least.

  The foundation code for this is sourced from [[http://bling.github.io/blog/2013/10/27/emacs-as-my-leader-vim-survival-guide/][bling's .emacs.d files]], but heavily customized
  for my liking, moved into one file, and dropped into org-mode for good
  measure.
* Settings
  Disable the toolbars.
  #+BEGIN_SRC emacs-lisp
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  #+END_SRC
  Disable vertical scrollbars in all frames.
  #+BEGIN_SRC emacs-lisp
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  #+END_SRC
  Disable the menu bar in console emacs.
  #+BEGIN_SRC emacs-lisp
  (unless (display-graphic-p) (menu-bar-mode -1))
  #+END_SRC
  Set the default font (only matters in graphical mode).
  #+BEGIN_SRC emacs-lisp
  (set-default-font "Terminus-10")
  #+END_SRC
  Ediff will do horizontal splits
  #+BEGIN_SRC emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
  #+END_SRC
  Disable backups and autosaves.
  #+BEGIN_SRC emacs-lisp
  ;disable backup
  (setq backup-inhibited t)
  ;disable auto save
  (setq auto-save-default nil)
  #+END_SRC
  Only scroll one line when near the bottom of the screen, instead of jumping
  the screen around.
  #+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 9999
        scroll-preserve-screen-position t)
  #+END_SRC
  Let me write `y` or `n` even for important stuff that would normally require
  me to fully type `yes` or `no`.
  #+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  #+END_SRC
  Enable the mouse in terminal mode.
  #+BEGIN_SRC emacs-lisp
  (xterm-mouse-mode 1)
  #+END_SRC
  UTF-8 everything!
  #+BEGIN_SRC emacs-lisp
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
  #+END_SRC
  This isn't a typewriter (even if it is a terminal); one space after sentences,
  please.
  #+BEGIN_SRC emacs-lisp
    (setq sentence-end-double-space nil)
  #+END_SRC
  Flash the frame to represent a bell.
  #+BEGIN_SRC emacs-lisp
    (setq visible-bell t)
  #+END_SRC
  The default of 16 is too low. Give me a 64-object mark ring.
  Across all files, make it 128.
  #+BEGIN_SRC emacs-lisp
    (setq mark-ring-max 64)
    (setq global-mark-ring-max 128)
  #+END_SRC
  Display the current function name in the modeline.
  #+BEGIN_SRC emacs-lisp
    (which-function-mode 1)
  #+END_SRC
  Show me the new saved file if the contents change on disk when editing.
  #+BEGIN_SRC emacs-lisp
    (global-auto-revert-mode 1)
  #+END_SRC
  Typing newlines triggers indentation.
  #+BEGIN_SRC emacs-lisp
    (electric-indent-mode 1)
  #+END_SRC
  Turn word-wrap on and redefine certain (simple) commands to work on visual
  lines, not logical lines.

  Also, show trailing whitespace.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'find-file-hook (lambda ()
                                (visual-line-mode)
                                (setq show-trailing-whitespace t)))
  #+END_SRC
  Seed all requests for random numbers.
  #+BEGIN_SRC emacs-lisp
    (random t) ;; seed
  #+END_SRC
  Don't let the cursor go over read-only text in minibuffers.
  #+BEGIN_SRC emacs-lisp
    (plist-put minibuffer-prompt-properties
               'point-entered 'minibuffer-avoid-prompt)
  #+END_SRC
  Indentation can never insert tabs. Note this is buffer-local, so we need
  to do `setq-default` for it to change everywhere.
  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)
  #+END_SRC
  Use linux kernel coding style for C-like languages.
  #+BEGIN_SRC emacs-lisp
    (setq-default c-default-style "linux"
                  c-basic-offset 8
                  tab-width 8)
  #+END_SRC
  Pretty print expression evaluations.
  #+BEGIN_SRC emacs-lisp
    (global-set-key [remap eval-expression] 'pp-eval-expression)
    (global-set-key [remap eval-last-sexp] 'pp-eval-last-sexp)
  #+END_SRC
* Package loading
  #+BEGIN_SRC emacs-lisp
        (add-to-list 'load-path user-emacs-directory)
        (add-to-list 'load-path (concat user-emacs-directory "config"))
        (add-to-list 'load-path (concat user-emacs-directory "elisp"))
        (require 'cl)
        (defun require-package (package)
          "Install given PACKAGE."
          (unless (package-installed-p package)
            (unless (assoc package package-archive-contents)
              (package-refresh-contents))
            (package-install package)))
        (require-package 'use-package)
        (require 'use-package)
        (defmacro after (feature &rest body)
        "After FEATURE is loaded, evaluate BODY."
        (declare (indent defun))
        `(eval-after-load ,feature
            '(progn ,@body)))
    
    (defmacro bind (&rest commands)
      "Convience macro which creates a lambda interactive command."
      `(lambda ()
         (interactive)
    ;; ',@' splices an evaluated value into the resulting list
    ;; That is, this will take a list and put it where this
    ;; Strange-looking construct is:
         ,@commands))
    
      (defun my-minibuffer-keyboard-quit ()
        "Abort recursive edit.
      In Delete Selection mode, if the mark is active, just deactivate it;
      then it takes a second \\[keyboard-quit] to abort the minibuffer."
        (interactive)
        (if (and delete-selection-mode transient-mark-mode mark-active)
            (setq deactivate-mark t)
          (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
          (abort-recursive-edit)))
    
      (defun set-transparency (alpha)
        "Sets the transparency of the current frame."
        (interactive "nAlpha: ")
        (set-frame-parameter nil 'alpha alpha))
    
      (defun my-google ()
        "Google the selected region if any, display a query prompt otherwise."
        (interactive)
        (browse-url
         (concat
          "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
          (url-hexify-string (if mark-active
                                 (buffer-substring (region-beginning) (region-end))
                               (read-string "Search Google: "))))))
    
      (defun my-eval-and-replace ()
        "Replace the preceding sexp with its value."
        (interactive)
        (backward-kill-sexp)
        (condition-case nil
            (prin1 (eval (read (current-kill 0)))
                   (current-buffer))
          (error (message "Invalid expression")
                 (insert (current-kill 0)))))
    
      (defun my-rename-current-buffer-file ()
        "Renames current buffer and file it is visiting."
        (interactive)
        (let ((name (buffer-name))
              (filename (buffer-file-name)))
          (if (not (and filename (file-exists-p filename)))
              (error "Buffer '%s' is not visiting a file!" name)
            (let ((new-name (read-file-name "New name: " filename)))
              (if (get-buffer new-name)
                  (error "A buffer named '%s' already exists!" new-name)
                (rename-file filename new-name 1)
                (rename-buffer new-name)
                (set-visited-file-name new-name)
                (set-buffer-modified-p nil)
                (message "File '%s' successfully renamed to '%s'"
                         name (file-name-nondirectory new-name)))))))
    
      (defun my-delete-current-buffer-file ()
        "Removes file connected to current buffer and kills buffer."
        (interactive)
        (let ((filename (buffer-file-name))
              (buffer (current-buffer))
              (name (buffer-name)))
          (if (not (and filename (file-exists-p filename)))
              (ido-kill-buffer)
            (when (yes-or-no-p "Are you sure you want to remove this file? ")
              (delete-file filename)
              (kill-buffer buffer)
              (message "File '%s' successfully removed" filename)))))
    
      ;; make sure $PATH is set correctly
      (require-package 'exec-path-from-shell)
      (ignore-errors ;; windows
        (exec-path-from-shell-initialize))
    
      (defun my-terminal-config (&optional frame)
        "Establish settings for the current terminal."
        (if (not frame) ;; The initial call.
            (xterm-mouse-mode 1)
          ;; Otherwise called via after-make-frame-functions.
          (if xterm-mouse-mode
              ;; Re-initialise the mode in case of a new terminal.
              (xterm-mouse-mode 1))))
      ;; Evaluate both now (for non-daemon emacs) and upon frame creation
      ;; (for new terminals via emacsclient).
      (my-terminal-config)
      (add-hook 'after-make-frame-functions 'my-terminal-config)
      ;; Hide startup messages
      (setq inhibit-splash-screen t
            inhibit-startup-echo-area-message t
            inhibit-startup-message t)
    
      (setq custom-file (concat user-emacs-directory "custom.el"))
      (when (file-exists-p custom-file)
        (load custom-file))
  #+END_SRC
  Move the cursor to the last position when I open a file.
  #+BEGIN_SRC emacs-lisp
      (use-package saveplace
        :config
        (progn
          (setq save-place-file (concat user-emacs-directory ".cache/places"))
          (setq-default save-place t)
          )
        )
  #+END_SRC
  Save a history of minibuffer access.
  #+BEGIN_SRC emacs-lisp
      (use-package savehist
        :config
          (progn
              (setq savehist-file (concat user-emacs-directory ".cache/savehist")
                  savehist-additional-variables '(search ring regexp-search-ring)
                  savehist-autosave-interval 60)
              (savehist-mode +1)
          )
      )
    
  #+END_SRC
  Save a history of recent files.
  #+BEGIN_SRC emacs-lisp
      (use-package recentf
        :config
        (progn
          (setq recentf-save-file (concat user-emacs-directory ".cache/recentf")
                recentf-max-saved-items 1000
                recentf-max-menu-items 500)
          (recentf-mode +1)
          ))
      ;; narrowing
      (put 'narrow-to-region 'disabled nil)
  #+END_SRC
* Dired-x
  "Extra" GNU features for Dired Mode.
** Features
- Dired local variables file: =.dired=
- Omitting “uninteresting” files from Dired listings
- Shell command guessing
- "Virtual Dired" allows you to view directories based on command output
- Cleaning commands
- Dired current file and file at point commands
** Code
   #+BEGIN_SRC emacs-lisp
     (require 'dired-x)
     (use-package dired-x
       :init
       (progn
          (add-hook 'dired-load-hook
                    (lambda ()
                      (load "dired-x")
                      ;; Set dired-x global variables here.  For example:
                      ;; (setq dired-guess-shell-gnutar "gtar")
                      ;; (setq dired-x-hands-off-my-keys nil)
                      ))
          (add-hook 'dired-mode-hook
                    (lambda ()
                      ;; Set dired-x buffer-local variables here.  For example:
                      ;; (dired-omit-mode 1)
                      ))
         )
       )
   #+END_SRC
* Uniquify
  Pretty distinct names for buffers
  #+BEGIN_SRC emacs-lisp
  ;; better buffer names for duplicates
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator "/"
        uniquify-ignore-buffers-re "^\\*" ; leave special buffers alone
        uniquify-after-kill-buffer-p t)
  #+END_SRC
* Auto-complete
  [[http://www.emacswiki.org/emacs/AutoComplete][Auto-complete]] is a visual autocompletion that uses popup menus. It is nicely broken
  with Linum enabled, but I keep it around in case one day I figure out how to make
  it work.
  #+BEGIN_SRC emacs-lisp
  (require-package 'auto-complete)
  (use-package auto-complete
  #+END_SRC
  Keeping this disabled for now; as mentioned above, it is broken.
  #+BEGIN_SRC emacs-lisp
    :disabled t
    :diminish auto-complete-mode
    :config
    (progn
      (setq
       ac-auto-show-menu 0.01
  #+END_SRC
  =ac-auto-start= specifies the length of a word required to enable auto-complete.
  #+BEGIN_SRC emacs-lisp
       ac-auto-start 2
       ac-comphist-file (expand-file-name ".cache/ac-comphist.dat" user-emacs-directory)
       ac-delay 0.01
       ac-quick-help-delay 0.5
       ac-use-fuzzy t
       ac-show-menu-immediately-on-auto-complete t)
       (dolist (mode '(vimrc-mode))
         (add-to-list 'ac-modes mode))
       (after 'linum
         (ac-linum-workaround))
      (defadvice ac-expand (before advice-for-ac-expand activate)
          (when (yas-expand)
            (ac-stop)))
      (use-package auto-complete-config
        :config
        (progn
          (ac-config-default)
          )
        )
    )
    )
  #+END_SRC
* Org-mode
  #+BEGIN_SRC emacs-lisp
    (use-package org
      :config
      (progn
        (global-set-key (kbd "C-c c") 'org-capture)
        (global-set-key (kbd "C-c a") 'org-agenda)
        (setq org-default-notes-file "~/.notes.org" org-log-done t)
        (use-package ob
          :config
          (progn
            (org-babel-do-load-languages
             'org-babel-load-languages
             '((R . t)
               (emacs-lisp . t)
               (python . t)
               ))
            )
          )
        )
      )
  #+END_SRC
* guide-key
  Overview from the [[https://github.com/kbkbkbkb1/guide-key][GitHub page]]
  #+BEGIN_QUOTE
  guide-key.el displays the available key bindings automatically and
  dynamically. guide-key aims to be an alternative of one-key.el.
  
  Here are some features of this library:

  - guide-key automatically pops up the keys following your favorite prefixes.
    Moreover, even if you change key bindings, guide-key follows the change
    dynamically.
  - guide-key can highlight particular commands. This makes it easy to find a
    command you are looking for, and to learn its key binding.
  - guide-key doesn’t overwrite existing commands and key bindings, so there is
    no interference with describe-key and describe-bindings.
  #+END_QUOTE
  #+BEGIN_SRC emacs-lisp
    (require-package 'guide-key)
    (use-package guide-key
      :diminish guide-key-mode
      :config
      (progn
        (setq guide-key/guide-key-sequence '("C-x" "C-c"))
        (setq guide-key/recursive-key-sequence-flag t)
        (guide-key-mode 1)
  #+END_SRC
  I'm relatively new to emacs, so having a short delay is beneficial.
  #+BEGIN_SRC emacs-lisp
        (setq guide-key/idle-delay 0.1)
        )
    )
  #+END_SRC
* Eyecandy
** Color scheme
   I use the =zenburn= color scheme, because it is easy on my eyes and doesn't look awful
   like most emacs themes. Emacs may have more capable syntax highlighting than vim, but
   damned if it isn't impossible to make it pretty, too.
   #+BEGIN_SRC emacs-lisp
  ;; Colors!
  (load-theme 'zenburn t)
   #+END_SRC
** Line highlighting
   This alone is supposed to enable highlighting the current line (especially with zenburn!)
   but it doesn't. Still, we need it in order to make line highlighting work.

   This might be because of my =~/.Xresources=, but who knows.
   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode t)
   #+END_SRC
   Now we set the background color for =hi-line=, in order to differentiate the background
   color.
   #+BEGIN_SRC emacs-lisp
     (set-face-background 'hl-line "#3e4446")
   #+END_SRC
** Smart modelines
   #+BEGIN_SRC emacs-lisp
  (require-package 'smart-mode-line)
  (use-package smart-mode-line
    :config
    (progn
      (setq sml/theme 'dark)
      (sml/setup)
    ))
   #+END_SRC
** =purty-mode=
   Simple pretty print for greek letters, etc.
   #+BEGIN_SRC emacs-lisp
     (require-package 'purty-mode)
     (use-package purty-mode
       :config
       (progn
         (purty-mode 1)
         ))
   #+END_SRC
** Line numbers
   Line numbers are provided by =linum=, with some added hacks to make them add space
   before "short" lines, so the line number column is all the same length. There is
   also a hack in place here to get =linum= to leave one blank space before the source
   code for the file.
   #+BEGIN_SRC emacs-lisp
     ;(require-package 'linum)
     ;(use-package linum
     ;  :config
     ;  (progn
     ;    (global-linum-mode 1)
     ;    (unless window-system
     ;      (add-hook 'linum-before-numbering-hook
     ;                (lambda ()
     ;                  (setq-local linum-format-fmt
     ;                              (let ((w (length (number-to-string
     ;                                                (count-lines (point-min) (point-max))))))
     ;                                (concat "%" (number-to-string w) "d"))))))
     ;    (defun linum-format-func (line)
     ;      (concat
     ;       (propertize (format linum-format-fmt line) 'face 'linum)
     ;       (propertize " " 'face 'mode-line)))
     ;    (unless window-system
     ;      (setq linum-format 'linum-format-func))
     ;    (setq linum-format "%4d "
     ;          linum-delay t)
     ;    )
     ;  )
     (require-package 'nlinum)
     (use-package nlinum
       :config
       (progn
         (nlinum-mode 1)
     ))
   #+END_SRC
   =rainbow-mode= is a minor mode for Emacs which displays strings
   representing colors with the color they represent as background.
   #+BEGIN_SRC emacs-lisp
  (require-package 'rainbow-mode)
  (use-package rainbow-mode)
   #+END_SRC
** rainbow delimiters
   #+BEGIN_SRC emacs-lisp
  (require-package 'rainbow-delimiters)
  (use-package rainbow-delimiters
    :init
    (progn
      (global-rainbow-delimiters-mode)
    )
    )
   #+END_SRC
** Whitespace mode
   #+BEGIN_SRC emacs-lisp
     (setq whitespace-style '(face lines-tail trailing))
     (global-whitespace-mode 1)
   #+END_SRC
* Copy/paste
  Emacs copy-paste does not work by default. First, we enable X selection as a copy-paste buffer.
  #+BEGIN_SRC emacs-lisp
  ; Basic copy-paste setup. From wiki.
  (setq x-select-enable-clipboard t)
  (setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
  #+END_SRC emacs-lisp
  Now, we hack copy-paste to work in the terminal.
  #+BEGIN_SRC emacs-lisp
  ; Brilliant working copy-paste (even in Evil mode!) ripped from:
  ; http://hugoheden.wordpress.com/2009/03/08/copypaste-with-emacs-in-terminal/
  (unless window-system
      (when (getenv "DISPLAY")
        ;; Callback for when user cuts
        (defun xsel-cut-function (text &optional push)
          ;; Insert text to temp-buffer, and "send" content to xsel stdin
          (with-temp-buffer
            (insert text)
            ;; I prefer using the "clipboard" selection (the one the
            ;; typically is used by c-c/c-v) before the primary selection
            ;; (that uses mouse-select/middle-button-click)
            (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
        ;; Call back for when user pastes
        (defun xsel-paste-function()
          ;; Find out what is current selection by xsel. If it is different
          ;; from the top of the kill-ring (car kill-ring), then return
          ;; it. Else, nil is returned, so whatever is in the top of the
          ;; kill-ring will be used.
          (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
            (unless (string= (car kill-ring) xsel-output)
              xsel-output )))
        ;; Attach callbacks to hooks
        (setq interprogram-cut-function 'xsel-cut-function)
        (setq interprogram-paste-function 'xsel-paste-function)
        ;; Idea from
        ;; http://shreevatsa.wordpress.com/2006/10/22/emacs-copypaste-and-x/
        ;; http://www.mail-archive.com/help-gnu-emacs@gnu.org/msg03577.html
  ))
  #+END_SRC

* editorconfig
  #+BEGIN_SRC emacs-lisp
  (require-package 'editorconfig)
  (use-package editorconfig)

  (require-package 'etags-select)
  (use-package etags-select
    :init
      (setq etags-select-go-if-unambiguous t)
    )

  (require-package 'windsize)
  (use-package windsize
    :init
    (progn
      (setq windsize-cols 16)
      (setq windsize-rows 8)
      (windsize-default-keybindings)
      )
    )
  #+END_SRC
* Code editing
** Projectile
   AKA =ctrl-p= for Emacs.
   #+BEGIN_SRC emacs-lisp
  (require-package 'projectile)
  (use-package projectile
    :diminish projectile-mode
    :config
    (progn
      (setq projectile-cache-file (concat user-emacs-directory ".cache/projectile.cache"))
      (setq projectile-known-projects-file (concat user-emacs-directory ".cache/projectile-bookmarks.eld"))
      (add-to-list 'projectile-globally-ignored-directories "elpa")
      (add-to-list 'projectile-globally-ignored-directories ".cache")
      (add-to-list 'projectile-globally-ignored-directories "node_modules")
      (projectile-global-mode 1)
      )
    )
   #+END_SRC
** Helm
   #+BEGIN_QUOTE
   Helm is incremental completion and selection narrowing framework
   for Emacs. It will help steer you in the right direction when
   you're looking for stuff in Emacs (like buffers, files, etc).
   
   Helm is a fork of anything.el originaly written by Tamas Patrovic
   and can be considered to be its successor. Helm sets out to clean
   up the legacy code in anything.el and provide a cleaner, leaner
   and more modular tool, that's not tied in the trap of backward
   compatibility.
   #+END_QUOTE
   #+BEGIN_SRC emacs-lisp
  (require-package 'helm)
  (use-package helm
    :config
    (progn
      (setq helm-command-prefix-key "C-c h")
      (setq helm-quick-update t)
      (require-package 'helm-swoop)
      (after 'helm-autoloads
        (after 'evil
            (global-set-key (kbd "M-x") 'helm-M-x)
            (define-key evil-normal-state-map (kbd "SPC e") 'helm-recentf)
            (define-key evil-normal-state-map (kbd "SPC t") 'helm-etags-select)
            (define-key evil-normal-state-map (kbd "SPC l") 'helm-swoop)
            (define-key evil-normal-state-map (kbd "SPC y") 'helm-show-kill-ring)
            (define-key evil-normal-state-map [f5] 'helm-mini)))
      (after 'projectile
        (require-package 'helm-projectile))
      )
    )
   #+END_SRC
** Ido
   Interactive =do= mode.
   #+BEGIN_SRC emacs-lisp
     (use-package ido
       :config
       (progn
         (ido-mode 1)
         (ido-everywhere 1)
         (setq ido-enable-prefix nil)
         (setq ido-use-virtual-buffers t)
         (setq ido-enable-flex-matching t)
         (setq ido-create-new-buffer 'always)
         (setq ido-show-dot-for-dired t)
         (setq ido-confirm-unique-completion nil)
         (setq ido-enable-last-directory-history nil)
         (setq ido-use-filename-at-point 'guess)
         (setq ido-save-directory-list-file
               (concat user-emacs-directory ".cache/ido.last"))
         (require-package 'ido-ubiquitous)
         (add-hook
          'ido-setup-hook
          (lambda()
            ;; On ido-find-file, let `~` mean `~/` for fastness.
            (define-key ido-file-dir-completion-map "~"
              (lambda ()(interactive)
                 (ido-set-current-directory "~/")
                 (setq ido-exit 'refresh)
                 (exit-minibuffer)))))
         (use-package ido-ubiquitous
           :config
           (progn
             (ido-ubiquitous-mode 1)
             )
           )
         (require-package 'flx-ido)
         (use-package flx-ido
           :defines (ido-cur-item ido-default-item ido-cur-list)
           :config
           (progn
             (flx-ido-mode 1)
             )
           )
         (require-package 'ido-vertical-mode)
         (use-package ido-vertical-mode
           :config
           (progn
             (ido-vertical-mode)
             )
           )
         )
       )
   #+END_SRC
*** Smex
    #+BEGIN_QUOTE
    Smex is a M-x enhancement for Emacs. Built on top of IDO, it
    provides a convenient interface to your recently and most
    frequently used commands. And to all the other commands, too.
    #+END_QUOTE
    #+BEGIN_SRC emacs-lisp
  (require-package 'smex)
  (use-package smex
    :config
    (progn
      (setq smex-save-file (concat user-emacs-directory ".cache/smex-items"))
      (global-set-key (kbd "C-x C-m") 'smex)
      (global-set-key (kbd "C-c C-m") 'smex)
      (smex-initialize)
  ))
    #+END_SRC
** Scss
   #+BEGIN_SRC emacs-lisp
     (require-package 'scss-mode)
     (use-package scss-mode
       :config
       (progn
         (autoload 'scss-mode "scss-mode")
         (add-to-list 'auto-mode-alist '("\\.scss\\'" . scss-mode))
         )
       )
   #+END_SRC
** Haskell
   #+BEGIN_SRC emacs-lisp
;     (require-package 'haskell-mode)
;     (use-package haskell-mode
;       :commands haskell-mode
;       :init
;       (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
;       :config
;       (progn
;         (define-key haskell-mode-map (kbd "C-x C-d") nil)
;         (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
;         (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-file)
;         (define-key haskell-mode-map (kbd "C-c C-b") 'haskell-interactive-switch)
;         (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
;         (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
;         (define-key haskell-mode-map (kbd "C-c M-.") nil)
;         (define-key haskell-mode-map (kbd "C-c C-d") nil)
;         (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile))
   #+END_SRC emacs-lisp
   Hack =haskell-mode= to play nice with evil. Modified code taken [[https://github.com/prooftechnique/.emacs.d/blob/6d08779adb8fe67acbe9ab82fe25e78a7fc40eb8/config/jhenahan-haskell.el][from this github]].
   #+BEGIN_SRC emacs-lisp
;         (add-hook 'haskell-mode-hook
;                   (lambda ()
;                     (turn-on-haskell-doc-mode)
;                     (after 'evil
;                       (setq evil-auto-indent nil))
;                     (turn-on-haskell-indentation)
;                     (ghc-init)))
;         (after 'linum (add-hook 'haskell-interactive-mode (lambda () (linum-mode 0))))
;         (after 'evil (add-hook 'haskell-interactive-mode (lambda () (evil-mode 0))))
;         (use-package haskell-mode-autoloads)
;         (use-package inf-haskell)
;         (use-package haskell-cabal
;           :init
;           (progn
;             (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile))
;           )
;         (use-package hs-lint)))
   #+END_SRC
** Git
   <<Magit>>
   #+BEGIN_SRC emacs-lisp
         (require-package 'magit)
         (use-package magit
           :config
           (progn 
               (setq magit-diff-options '("--histogram"))
               (global-set-key (kbd "C-x g") 'magit-status))
     ;          (global-git-gutter+-mode)
           )
     
     (require-package 'gist)
       
   #+END_SRC
** Ag: speedy inter-file grep
   #+BEGIN_SRC emacs-lisp
   (require-package 'ag)
   (use-package ag
     :init
     (progn
       (setq ag-highlight-search t)
       (add-hook 'ag-mode-hook (lambda () (toggle-truncate-lines t)))
       (add-hook 'ag-mode-hook (lambda () (linum-mode 0)))
     )
   )
   #+END_SRC
** Project-explorer
   #+BEGIN_SRC emacs-lisp
   (require-package 'project-explorer)
   (use-package project-explorer
     :commands (progn project-explorer project-explorer-open pe/show-file)
     :config
       (progn
         (setq pe/omit-regex (concat pe/omit-regex "\\|^node_modules$"))
       )
     )
   #+END_SRC
* Flycheck
  #+BEGIN_SRC emacs-lisp
    (require-package 'flycheck)
    (use-package flycheck
      :config
      (progn
        (setq flycheck-check-syntax-automatically '(save mode-enabled))
        (setq flycheck-checkers (delq 'emacs-lisp-checkdoc flycheck-checkers))
        (setq flycheck-checkers (delq 'html-tidy flycheck-checkers))
        (global-flycheck-mode 1)
        (after 'evil (add-hook 'flycheck-error-list-mode-hook (lambda () (evil-mode 0))))
        )
      )
  #+END_SRC
* ace-jump-mode
  #+BEGIN_SRC emacs-lisp
    (require-package 'ace-jump-mode)
    (use-package ace-jump-mode
      :config
      (progn
        (after 'evil
          ; Not sure if the `after` here is necessary, but anyway:
          (after 'ace-jump-mode-autoloads
            (define-key evil-normal-state-map (kbd "SPC j") 'ace-jump-char-mode)
            (define-key evil-motion-state-map (kbd "SPC") 'evil-ace-jump-char-mode)
            (define-key evil-motion-state-map (kbd "S-SPC") 'evil-ace-jump-line-mode))
          ; These will definitely work:
          (key-chord-define evil-normal-state-map "jw" 'ace-jump-word-mode)
          (key-chord-define evil-normal-state-map "jc" 'ace-jump-char-mode)
          (key-chord-define evil-normal-state-map "jl" 'ace-jump-line-mode))
        ))
    
  #+END_SRC
* Elisp-slime-nav
  #+BEGIN_SRC emacs-lisp
  (require-package 'elisp-slime-nav)
  (use-package elisp-slime-nav
    :config
    (progn
      (defun my-lisp-hook ()
        (progn
          (elisp-slime-nav-mode)
          (turn-on-eldoc-mode)))
      (add-hook 'emacs-lisp-mode-hook 'my-lisp-hook)
      (add-hook 'lisp-interaction-mode-hook 'my-lisp-hook)
      (add-hook 'ielm-mode-hook 'my-lisp-hook)
      )
    )
  #+END_SRC
* Key chords
  #+BEGIN_SRC emacs-lisp
    (require-package 'key-chord)
    (use-package key-chord :diminish key-chord-mode
      :config
      (progn
        (key-chord-mode 1)))
  #+END_SRC
* Evil
  Note: requires undo-tree.
  #+BEGIN_SRC emacs-lisp
    (require-package 'undo-tree)
    (use-package undo-tree
      :diminish undo-tree-mode
      :init
      (progn
        (require-package 'evil)
        (require-package 'evil-visualstar)
        (require-package 'evil-nerd-commenter)
        (require-package 'evil-indent-textobject)
        (require-package 'evil-matchit)
        (require-package 'surround)
    
        (use-package evil
          :config
          (progn
            (evil-mode 1)
            (setq evil-want-C-u-scroll t
                evil-want-C-w-in-emacs-state t
                evil-search-module 'evil-search
                evil-magic 'very-magic
                evil-emacs-state-cursor '("red" box)
                evil-normal-state-cursor '("green" box)
                evil-insert-state-cursor '("orange" bar)
                )
            (setq evil-replace-state-cursor '("red" box))
            
            (require-package 'evil-leader)
            (use-package evil-leader
              :config
              (progn
                (global-evil-leader-mode)
                (evil-leader/set-leader ",")
                (setq my-eshell-buffer-count 0)
                (evil-leader/set-key
                    "w" 'save-buffer
                    "e" (kbd "C-x C-e")
                    "E" (kbd "C-M-x")
                    "c" (bind
                         (evil-window-split)
                         (setq my-eshell-buffer-count (+ 1 my-eshell-buffer-count))
                         (eshell my-eshell-buffer-count))
                    "C" 'customize-group
                    "b d" 'kill-this-buffer
                    "v" (kbd "C-w v C-w l")
                    "s" (kbd "C-w s C-w j")
                    "g s" 'magit-status
                    "g l" 'magit-log
                    "g d" 'vc-diff
                    "P" 'package-list-packages
                    "h" help-map
                    "h h" 'help-for-help-internal)
                )
              )
            (use-package evil-nerd-commenter
              :config
              ;; Type 'gcc' to comment the current line.
              (progn (setq evilnc-hotkey-comment-operator "gc")))
            (use-package evil-indent-textobject)
            (use-package evil-visualstar)
            (use-package evil-matchit
              :config
              (progn
                (after 'evil-matchit
                  (define-key evil-normal-state-map "%" 'evilmi-jump-items))
                ))
            (use-package surround
              :config
                (progn
                  (global-surround-mode 1)
                  )
              )
    
            (dolist (mode '(eshell-mode
                            shell-mode
                            term-mode
                            terminal-mode
                            comint-mode
                            skewer-repl-mode
                            profiler-report-mode
                            erc-mode weechat-mode
                            direx:direx-mode
                            project-explorer-mode))
              (evil-set-initial-state mode 'emacs))
    
            (evil-define-text-object my-evil-next-match (count &optional beg end type)
              "Select next match."
              (evil-ex-search-previous 1)
              (evil-ex-search-next count)
              (list evil-ex-search-match-beg evil-ex-search-match-end))
    
            (evil-define-text-object my-evil-previous-match (count &optional beg end type)
              "Select previous match."
              (evil-ex-search-next 1)
              (evil-ex-search-previous count)
              (list evil-ex-search-match-beg evil-ex-search-match-end))
    
            (define-key evil-motion-state-map "gN" 'my-evil-previous-match)
            (define-key evil-motion-state-map "gN" 'my-evil-previous-match)
    
            (defadvice evil-ex-search-next (after advice-for-evil-ex-search-next activate)
              (evil-scroll-line-to-center (line-number-at-pos)))
    
            (defadvice evil-ex-search-previous (after advice-for-evil-ex-search-previous activate)
              (evil-scroll-line-to-center (line-number-at-pos)))
    
            ;;; esc quits
            (define-key evil-normal-state-map [escape] 'keyboard-quit)
            (define-key evil-visual-state-map [escape] 'keyboard-quit)
    
    
          (after 'git-gutter+-autoloads
            (define-key evil-normal-state-map (kbd "[ h") 'git-gutter+-previous-hunk)
            (define-key evil-normal-state-map (kbd "] h") 'git-gutter+-next-hunk)
            (define-key evil-normal-state-map (kbd ", g a") 'git-gutter+-stage-hunks)
            (define-key evil-normal-state-map (kbd ", g r") 'git-gutter+-revert-hunks)
            (evil-ex-define-cmd "Gw" (bind (git-gutter+-stage-whole-buffer))))
    
          (define-key evil-visual-state-map (kbd "SPC SPC") 'helm-M-x)
          (define-key evil-normal-state-map (kbd "SPC SPC") 'helm-M-x)
    
          (define-key evil-normal-state-map (kbd "SPC o") 'helm-imenu)
          (define-key evil-normal-state-map (kbd "SPC b") 'helm-buffers-list)
          (define-key evil-normal-state-map (kbd "SPC B") 'ibuffer)
    
          (define-key evil-normal-state-map (kbd "SPC k") 'ido-kill-buffer)
          (define-key evil-normal-state-map (kbd "SPC f") 'ido-find-file)
    
          (define-key evil-normal-state-map (kbd "[ SPC") (bind (evil-insert-newline-above) (forward-line)))
          (define-key evil-normal-state-map (kbd "] SPC") (bind (evil-insert-newline-below) (forward-line -1)))
          (define-key evil-normal-state-map (kbd "[ e") (kbd "ddkP"))
          (define-key evil-normal-state-map (kbd "] e") (kbd "ddp"))
          (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer)
          (define-key evil-normal-state-map (kbd "] b") 'next-buffer)
          (define-key evil-normal-state-map (kbd "[ q") 'previous-error)
          (define-key evil-normal-state-map (kbd "] q") 'next-error)
    
          (define-key evil-normal-state-map (kbd "g p") (kbd "` [ v ` ]"))
    
          (after 'etags-select
            (define-key evil-normal-state-map (kbd "g ]") 'etags-select-find-tag-at-point))
    
          (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
          (define-key evil-normal-state-map (kbd "C-q") 'universal-argument)
    
          (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
          (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
          (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
          (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
    
          (define-key evil-motion-state-map "j" 'evil-next-visual-line)
          (define-key evil-motion-state-map "k" 'evil-previous-visual-line)
    
          (define-key evil-normal-state-map (kbd "Y") (kbd "y$"))
    
          (define-key evil-visual-state-map (kbd ", e") 'eval-region)
    
          ;; emacs lisp
          (after 'elisp-slime-nav-autoloads
            (evil-define-key 'normal emacs-lisp-mode-map (kbd "g d") 'elisp-slime-nav-find-elisp-thing-at-point)
            (evil-define-key 'normal emacs-lisp-mode-map (kbd "K") 'elisp-slime-nav-describe-elisp-thing-at-point))
    
          (after 'ag-autoloads
            (define-key evil-normal-state-map (kbd "SPC /") 'ag-regexp-project-at-point))
    
          (after 'multiple-cursors
            (define-key evil-visual-state-map (kbd "C->") 'mc/mark-all-like-this)
            (define-key evil-normal-state-map (kbd "C->") 'mc/mark-next-like-this)
            (define-key evil-normal-state-map (kbd "C-<") 'mc/mark-previous-like-this))
    
          (after 'magit
            (define-key magit-status-mode-map (kbd "C-n") 'magit-goto-next-sibling-section)
            (define-key magit-status-mode-map (kbd "C-p") 'magit-goto-previous-sibling-section)
            (evil-add-hjkl-bindings magit-status-mode-map 'emacs
              "K" 'magit-discard-item
              "l" 'magit-key-mode-popup-logging
              "h" 'magit-toggle-diff-refine-hunk))
    
          ;; butter fingers
          (evil-ex-define-cmd "Q" 'evil-quit)
          (evil-ex-define-cmd "Qa" 'evil-quit-all)
          (evil-ex-define-cmd "QA" 'evil-quit-all)
          )
          )
    )
    )
  #+END_SRC
** Evil-org-mode
   Code copied directly from [[https://github.com/edwtjo/evil-org-mode/blob/master/evil-org.el][GitHub repo]].
   #+BEGIN_SRC emacs-lisp
     (after 'evil
       (define-minor-mode evil-org-mode
         "Buffer local minor mode for evil-org"
         :init-value nil
         :lighter " EvilOrg"
         :keymap (make-sparse-keymap) ; defines evil-org-mode-map
         :group 'evil-org)
     
     ;  (define-minor-mode evil-org-src-mode
     ;    "Buffer local minor mode for evil-org-src"
     ;    :init-value nil
     ;    :lighter " EvilOrgSrc"
     ;    :keymap (make-sparse-keymap) ; defines evil-org-mode-map
     ;    :group 'evil-org
     ;    )
     
       (add-hook 'org-mode-hook 'evil-org-mode) ;; only load with org-mode
     ;  (add-hook 'org-src-mode-hook 'evil-org-src-mode)
     ;  (add-hook 'org-src-mode-hook (lambda () ((diminish 'evil-org-src-mode))))
       
       (setq evil-auto-indent nil)
     
       (defun always-insert-item ()
         "Force insertion of org item"
         (if (not (org-in-item-p))
             (insert "\n- ")
           (org-insert-item))
         )
     
       (defun evil-org-eol-call (fun)
         "Go to end of line and call provided function"
         (end-of-line)
         (funcall fun)
         (evil-append nil)
         )
     
     ;  (evil-define-key 'normal evil-org-src-mode-map
     ;    "&" 'org-edit-src-exit)
     
       ;; normal state shortcuts
       (evil-define-key 'normal evil-org-mode-map
         "gh" 'outline-up-heading
         "gj" (if (fboundp 'org-forward-same-level) ;to be backward compatible with older org version
                  'org-forward-same-level
                'org-forward-heading-same-level)
         "gk" (if (fboundp 'org-backward-same-level)
                  'org-backward-same-level
                'org-backward-heading-same-level)
         "gl" 'outline-next-visible-heading
         "t" 'org-todo
         "T" '(lambda () (interactive) (evil-org-eol-call '(org-insert-todo-heading nil)))
         "H" 'org-beginning-of-line
         "L" 'org-end-of-line
         ";t" 'org-show-todo-tree
         "o" '(lambda () (interactive) (evil-org-eol-call 'always-insert-item))
         "O" '(lambda () (interactive) (evil-org-eol-call 'org-insert-heading))
         "$" 'org-end-of-line
         "^" 'org-beginning-of-line
         "<" 'org-metaleft
         ">" 'org-metaright
         "&" 'org-edit-src-code
         ";a" 'org-agenda
         "-" 'org-cycle-list-bullet
         (kbd "TAB") 'org-cycle)
     
       ;; normal & insert state shortcuts.
       (mapc (lambda (state)
               (evil-define-key state evil-org-mode-map
                 (kbd "M-l") 'org-metaright
                 (kbd "M-h") 'org-metaleft
                 (kbd "M-k") 'org-metaup
                 (kbd "M-j") 'org-metadown
                 (kbd "M-L") 'org-shiftmetaright
                 (kbd "M-H") 'org-shiftmetaleft
                 (kbd "M-K") 'org-shiftmetaup
                 (kbd "M-J") 'org-shiftmetadown
                 (kbd "M-o") '(lambda () (interactive)
                                (evil-org-eol-call
                                 '(lambda()
                                    (org-insert-heading)
                                    (org-metaright))))
                 (kbd "M-t") '(lambda () (interactive)
                                (evil-org-eol-call
                                 '(lambda()
                                    (org-insert-todo-heading nil)
                                    (org-metaright))))
                 ))
             '(normal insert))
       )
   #+END_SRC
* expand-region
  #+BEGIN_SRC emacs-lisp
  (require-package 'expand-region)
  (use-package expand-region)

  #+END_SRC
* keybindings
  Hitting =[escape]= exits minibuffers.
  #+BEGIN_SRC emacs-lisp
  (define-key minibuffer-local-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'my-minibuffer-keyboard-quit)
  #+END_SRC
  This makes evil's hjkl bindings work in the package list.
  #+BEGIN_SRC emacs-lisp
  (after 'package
    (after 'evil
      (evil-add-hjkl-bindings package-menu-mode-map 'emacs))
    )
  #+END_SRC
  Not sure why this needs to be corrected, but presumably Project Explorer's mappings
  interfere with Evil-mode bindings for switching windows.
  #+BEGIN_SRC emacs-lisp
  (after 'project-explorer-autoloads
    (after 'project-explorer
      (after 'evil
        (define-key project-explorer-mode-map (kbd "C-l") 'evil-window-right)))
  #+END_SRC
  Quick hotkeys for project explorer, bound to function keys.
  #+BEGIN_SRC emacs-lisp
    (global-set-key [f2] 'project-explorer-open)
    (global-set-key [f3] 'pe/show-file))
  
  (after 'comint
    (define-key comint-mode-map [up] 'comint-previous-input)
    (define-key comint-mode-map [down] 'comint-next-input))
  
  (after 'auto-complete
    (define-key ac-completing-map (kbd "C-n") 'ac-next)
    (define-key ac-completing-map (kbd "C-p") 'ac-previous))
  
  (after 'expand-region-autoloads
    (global-set-key (kbd "C-=") 'er/expand-region))
  
  ;; mouse scrolling in terminal
  (unless (display-graphic-p)
    (global-set-key [mouse-4] (bind (scroll-down 1)))
    (global-set-key [mouse-5] (bind (scroll-up 1))))
  
  (global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "C-x C-k") 'kill-this-buffer)
  (global-set-key (kbd "C-x g") 'my-google)
  (global-set-key (kbd "C-c e") 'my-eval-and-replace)
  
  ;; have no use for these default bindings
  (global-unset-key (kbd "C-x m"))
  #+END_SRC
** Unbound keys
   The following is taken from [[http://www.emacswiki.org/emacs/unbound.el][EmacsWiki]], and the license of =unbound.el=
   is GPL version 2 or (at your option) any later version.
   #+BEGIN_QUOTE
   unbound.el --- find convenient unbound keystrokes
   
   Copyright (C) 2007 Davis Herring
   
   Author: Davis Herring <herring@lanl.gov>
   Version: 0.1
   Maintainer: Davis Herring
   Keywords: keyboard
   #+END_QUOTE
   The author provided some commentary on the script, shown below:
   #+BEGIN_QUOTE
   Commentary:
   The only entry point is `describe-unbound-keys'; it prompts for the maximum
   complexity to allow, which should probably be at least 5 to find enough
   keys to be worthwhile.  Lisp may call just `unbound-keys' to get a list of
   key representations suitable for `define-key'.
   #+END_QUOTE
   The source code for =unbound.el= is shown below:
   #+BEGIN_SRC emacs-lisp
  (eval-when-compile (require 'cl))       ; for `dotimes', `push' (Emacs 21)
  
  (defcustom unbound-modifiers '(control meta shift)
  "Modifiers to consider when searching for unbound keys."
  :type '(set (const control) (const meta) (const shift)
             (const super) (const hyper) (const alt)))
  
  (defvar unbound-key-list
  (let (keys)
   (dotimes (i (- ?\d ?\  -1))
     (push (+ i ?\ ) keys))
   (dotimes (i 12)
     (push (intern (format "f%s" (1+ i))) keys))
   (append '(?\t ?\r ?\e) (nreverse keys)
           '(insert delete home end prior next up down left right)))
  "Keys to consider when searching for unbound keys.")
  
  (defun key-complexity (key)
  "Return a complexity score for key sequence KEY.
  Currently KEY must be of the [(control shift ?s) ...] format."
  (let ((ret 0))
   (dotimes (i (length key) ret)
     (setq ret (+ ret (* i 2) (key-complexity-1 (aref key i)))))))
  
  ;; This is somewhat biased for US keyboards.
  (defun key-complexity-1 (key)           ; key:=(modifiers... key)
  (+ (if (memq 'control key) 1 0)
    (if (memq 'meta key) 2 0)
    (if (memq 'shift key) 3 0)
    (if (memq 'super key) 4 0)
    (if (memq 'hyper key) 4 0)
    (if (memq 'alt key) 3 0)
    (* 2 (1- (length key)))
    (progn
      (setq key (car (last key)))
      (if (integerp key)
          (cond ((and (>= key ?a) (<= key ?z)) 0)
                ((and (>= key ?A) (<= key ?Z)) 6) ; capitals are weird
                ((and (>= key ?0) (<= key ?9)) 2)
                ((memq key '(?\b ?\r ?\ )) 1)
                ;; Unshifted punctuation (US keyboards)
                ((memq key '(?` ?- ?= ?\t ?[ ?] ?\\ ?\; ?' ?, ?. ?/)) 3)
                ;; Other letters -- presume that one's keyboard has them if
                ;; we're going to consider binding them.
                ((let (case-fold-search)
                   (string-match
                    "[016A]" (category-set-mnemonics
                              (char-category-set key)))) 2)
                (t 5))
        7))))
  
  ;; Quiet the byte compiler
  (defvar unbound-keys nil
  "Used internally by `unbound-keys'.")
  
  (defun unbound-keys (max)
  "Return a list of unbound keystrokes of complexity no greater than MAX.
  Keys are sorted by their complexity; `key-complexity' determines it."
  (let (unbound-keys)
   (unbound-keys-1 max nil nil)
   (mapcar 'car (sort unbound-keys (lambda (k l) (< (cdr k) (cdr l)))))))
  
  ;; Adds to `unbound-keys'.
  (defun unbound-keys-1 (max map pfx)
  (dolist (base unbound-key-list)
   (dotimes (modi (lsh 1 (length unbound-modifiers)))
     (let ((key (list base)))
       (dotimes (j (length unbound-modifiers))
         (unless (zerop (logand modi (lsh 1 j)))
           (push (nth j unbound-modifiers) key)))
       (let ((total (vconcat pfx (list key))) comp)
         ;; Don't use things that get translated and bound.  This isn't
         ;; perfect: it assumes that the entire key sequence is translated.
         (unless (or (let ((trans (lookup-key function-key-map total)))
                       (and (vectorp trans) (key-binding trans)))
                     ;; Don't add `shift' to any graphic character; can't
                     ;; type it, or it's redundant.
                     (and (memq 'shift key) (integerp base)
                          (> base ?\ ) (<= base ?~))
                     ;; Don't add `control' when it generates another
                     ;; character we use:
                     (and (memq 'control key) (integerp base)
                          (< base ?`)
                          (memq (- base 64) unbound-key-list))
                     ;; Limit the total complexity:
                     (> (setq comp (key-complexity total)) max))
           (let ((res (if map (lookup-key map (vector key))
                        (key-binding (vector (if (cdr key) key (car key)))))))
             (cond ((keymapp res)
                    ;; Don't add anything after an ESC, to avoid Meta
                    ;; confusion.
                    (unless (eq base ?\e)
                      (unbound-keys-1 max res total)))
                   (res)
                   (t (push (cons total comp) unbound-keys))))))))))
  
  ;;;###autoload
  (defun describe-unbound-keys (max)
  "Display a list of unbound keystrokes of complexity no greater than MAX.
  Keys are sorted by their complexity; `key-complexity' determines it."
  (interactive "nMaximum key complexity: ")
  (with-output-to-temp-buffer "*Unbound Keys*"
   (let ((keys (unbound-keys max)))
     (princ (format "%s unbound keys with complexity at most %s:\n"
                    (length keys) max))
     (princ (mapconcat 'key-description keys "\n")))))
  
  (provide 'unbound)
  
  ;; Local variables:
  ;; indent-tabs-mode: nil
  ;; End:
  
  ;; unbound.el ends here
   #+END_SRC
